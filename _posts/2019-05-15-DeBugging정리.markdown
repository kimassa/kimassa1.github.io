# DeBugging

___

TRACEBACK 분석하기

- 아래서부터 역순으로 읽어나가되 내가 입력한 부분이 아닌 내용(내부에러)는 skip하자
- 아래서부터 가까운 부분(최근 에러)에서 발생했을 확률이 높음
- 에러가 일어난 부분의 원인이 되는 코드를 print()하여 결과물을 확인해보자

## 1. 프로그램의 길

## 2. 변수/표현식/문장



Syntax Error(구문오류)
-> 프로그램을 종료해버림

Runtime Error(런타임오류) : Exception
-> 실행전에는 나타나지않음! 실행후에야 나타나는 런타임 오류!

Semantic Error(의미오류)
-> 프로그램이 종료가 안됨!!

## 3. 함수

프로그래밍 =  프로그램이 원하는 동작을 할때까지 프로그램을 점진적으로 디버깅하는 것

## 4. 인터페이스 디자인
Pre condition(사전조건)
-> 함수의 실행전에 반드시 마련되야하는 조건 
호출자가 책임을 진다
호출자가 사전조건을 어기지않았는지 확인!

Post condition(사후조건)
-> 함수의 종료에 필요한 조건

## 5. 조건문과 재귀
오류메세지 확인할 부분
- 에러의 종류가 무엇인가?
- 에러가 발생한 곳은 어디인가?

white space error 잘찾아야함

오류메시지는 5번줄을 가리키지만, 해당줄에는 잘못된 것이 없다
진짜 오류를 찾으려면 ratio값을 print로 확인해봐야하고, 이 값이 0이라는 것을 알 수있다.
문제는 4번줄에 있다. 4번줄은 부동소수점 나눗셈대신 몫연산을 사용했다.

(중요)결론 -> 
[1] 오류메세지가 모두 올바르다고 가정해서는 안된다!!
[2] 오류메세지가 발생한 부분 이외에 발생의 원인이 될만한 부분을 거슬러 올라가며 print찍어서 내용을 확인하자!

## 6. 결과가 있는 함수
함수가 동작하지 않는다면 3가지 가능성이 있음
[1] 함수가 가져오는 인수에 뭔가 문제가 있다. Pre-condition(사전조건)에 위배되는지 확인하기 
[2] 함수 자체에 뭔가 문제가 있다. Post-condition(사후조건)에 위배되는지 확인하기
[3] 반환값에 뭔가 문제가 있다. 또는 반환값을 사용하는 방식에 문제가 있다.


함수의 시작부분에 print문을 추가해서 인자들의 값을(또는 타입역시)표시해 보자!
사전조건을 명확하게 검사하는 코드를 작성해보자!

인자에 문제가 없어보이면 return문앞에 print문을 추가하여 반환값을 표시해보자!
직접 함수 실행시켜서 호출하라! 결과를 확인하기 쉬운값으로 함수를 호출하면 좋겠지!

함수가 제대로 동작하면 반환값이 올바르게 사용되는지(또는 전혀 사용되지 않는지)확인하라!

함수의 시작과 끝에 print문을 추가하면 실행흐름을 시각적으로 보이게 만들수있다!


## 7. 반복

디버깅 시간을 줄이는 방법! -> '분할하며 디버깅 하라!'
중간 지점 검사해서 
문제있으면 앞부분이 문제!
문제 없으면 뒷부분이 문제!

오류가 있을만한 위치와 검사를 넣기쉬운 위치를 생각해라!
검사 위치의 앞과 뒤에서 버그가 같은지 확인할 수 있다고 생각되는 위치를 선택하라!

## 8. 문자열

[여기 다시보기!!]
index를 사용해 시퀀스의 값을 순회하는 경우 순회의 시작과 끝을 올바르게 얻는 것이 어려움!

에러가 표시된줄 바로 앞에 index값을 print해보자!
다이어그램을 그려보자!

## 9. 워드플레이
테스트는 어렵다
테스트는
버그의 존재를 알려줄수는 있지만
버그의 부재를 알려줄수는 없다

## 10. 리스트

***리스트 일반적인 실수

1. 대부분의 리스트 메서드는 인수를 수정하고 None을 반환한다.

이는 새로운 문자열을 생성하고 원본을 변경하지않는 문자열 메서드와 반대이다.
문자열코드는 보통 이런식으로 작성한다

word = word.strip()

리스트코드를 이런식으로 작성하고 싶을것이다.

t=t.sort() #틀렸음

sort는 None을 반환하므로 t를 사용하려는 이후의 작업은 실패하게 된다
리스트 메서드와 연산자를 사용하기전에 공식문서를 자세히 읽고 상호작용 모드에서 테스트해봐야한다


2. 용법을 선택하고 계속 사용하라.
리스트가 갖는 문제는 처리하는 방법이 너무 많다는것이다
예를들어 리스트에서 원소를 제거하고싶다면 pop remove del을 사용할수있고
심지어 슬라이스 할당문을 사용할수도있다.

원소를 추가하고 싶다면 append메서드나 + 연산자를 사용할수있다.
t가 리스트이고, x는 리스트원소라고 하면 다음은 올바른 코드이다

t.append(x)
t = t+[x]
t += [x]

그러나 다음코드는 모두 틀렸음.

t.append([x])   #틀렸음
t=t.append(x)   #틀렸음
t+[x]           #틀렸음
t=t+x           #틀렸음

상호작용 모드에서 예제 각각을 시험해보면서 어떻게 동작하는지 확실하게 이해해두자.
예제에서 마지막줄은 런타임오류를 일으킨다.
나머지 세개는 문법은 맞지만 잘못된 결과가 된다.


3. 복제본을 만들어 별칭사용을 줄인다.
인수를 수정하는 sort같은 메서드를 사용하고 싶지만 원본리스트는 그대로 유지하고 싶다면 복제본을 만드는게 좋다.

- t = [3,1,2]
- t2 = t[:]
- t2.sort()
- t
[3,1,2]
- t2
[1,2,3]

이 예제에서는 내장함수 sorted도 사용할수있다.
sorted는 새로생성한, 정렬된 리스트를 반환하고 원본은 변경하지않는다.

- t2.sorted(t)
- t
[3,1,2]
- t2
[1,2,3]

## 11. 사전

작업하는 데이터셋이 커지면 일일이 출력해보고 확인하면서 디버깅하는게 번거롭고 불편해지기 시작한다.
데이터셋이 클때도 디버깅을 잘할수있는 몇가지방법을 소개하겠다.

1. 입력크기를 줄이자
가능하다면 데이터셋의 크기를 줄여라.
예를들어 프로그램에서 텍스트파일을 읽어야한다면
처음 10줄정도만 읽어보거나 가능한 작은예제로 시작하는게 좋다
텍스트 파일을 수정하거나 프로그램을 수정해서 처음 n줄만 읽는 방법을 쓰라
오류가 있다면 오류를 조작할수있는 가장 작은값까지 n을 줄여보고
오류를 발견하고 수정할때까지 점진적으로 n을 늘려보자


2. 요약정보와 타입을 확인하자
전체 데이터셋을 출력하고 확인하기보단 데이터의 요약정보를 출력해보라
예를 들어 사전에서 항목의 개수를 출력해보거나 리스트 숫자들의 합을 출력해보라

올바른 타입이 아닌값이 런타임오류가 발생하는 일반적인 원인이다!!
이런종류의 오류를 디버깅할때는 값의 타입을 출력해보자!!


3. 자기점검코드를 작성하자
때로는 오류를 자동으로 확인하는 코드를 작성해야한다.
예를 들어 리스트 숫자들의 평균을 계산한다면 결과가 리스트에서 가장 큰원소보다 큰지
가장 작은 원소보다 작은지 확인하는 것이다.
이런종류의 검사는 상식을 벗어난 결과를 탐지하기때문에 sanity check라고 부른다

다른 종류의 검사로는 두가지 다른 계산결과를 비교해서 일치하는지 확인하는 것이다.
이를 일관성 검사 consistency check이라고 한다!!

4. 출력을 서식화하자

디버깅 출력을 서식화 하면 오류지점을 찾기 쉬워진다.
pprint모듈에는 내장타입을 사람이 읽기쉬운 서식으로 출력하는 pprint함수가 있다.
scaffolding을 만드는데 시간 들인만큼 디버깅 시간이 줄어든다!!

## 12. 튜플

리스트 사전 튜플은 자료구조라고 한다
이장에서는 
키는 튜플인데 값은 리스트인 사전이나 튜플의 리스트같은 복합자료구조를 살펴봤다
복합자료구조는 유용하다!
그러나 오류가 발생하기 쉽다!
오류의 원인은 잘못된 타입, 크기, 구조를 갖는게 원인이다 => 성형오류라고 함 shape error!
(예를들어 정수가 1개인 리스트를 기대했는데 리스트안에 있는 정수가 아니라 보통의 정수를 제공하면 에러남)

structshape!! 사용하자!



## 13. 자료구조 고르기

특히 어려운 버그를 잡고 있다면 5가지 시도해보자
1. 읽기
2. 실행
3. 깊이 생각하기 
4. 고무오리 기법 Rubbered Ducking
5. 물러나기



## 14. 파일

파일을 읽고 쓸때 공백문제가 발생할수있음
공백 탭 새줄문자는 일반적으로 보이지 않기때문에 이런 오류는 디버그하기 어려울수 있다.

내장함수 repr가 이런경우에 유용함
객체를 인수로 받아서 객체의 문자열 표현을 반환한다.



## 15. 클래스와 객체

존재하지않는 속성에 접근하면
AttributeError가 발생함

AttributeError : instance has no attribute 'z'

객체의 타입이 무엇인지 확인을 하자

type(객체)

객체가 클래스의 인스턴스인지 확인할때에는 isinstance를 사용하자.

- isinstance(p,Point)
True

객체에 어떤속성이 있는지는 내장함수 hasattr을 사용하자!
- hasattr(p,'x')

첫번째 인수에는 어떤객체라도 쓸수있지만 두번째인수는 속성이름이 들어있는 문자열이어야한다.

객체에 원하는 속성이 있는지 알아보기 위해 try문을 사용하는 방법도있다.

try:
    x = p.x
except AttributeError:
    x = 0

이러한 방법을 사용하면 다양한 타입에 대해 동작하는 함수를 좀더 쉽게 작성할수있다
다형성!



## 16. 클래스와 함수

miniute와 second의 값이 
불변조건 invariant

## 17. 클래스와 메서드


## 18. 상속


## 19. 알아두면 좋은 나머지


## 20. 디버깅

1. 구문 오류(Syntax Error)
변경을 계속하지만 전혀차이가 없다

2. 런타임 오류(Runtime Error)
(1)프로그램이 아무것도 하지않는다

(2)프로그램이 응답하지않는다

-무한루프

-무한재귀
잠시 실행되다가 최대 재귀 깊이 초과 오류(maximum recursion depth exceeded)일으킨다
base case인지 확인해야함
함수에는 재귀호출을 하지않고 복귀하는 조건이 있어야함!
아니면 알고리즘 다시짜!
함수의 시작부분에 인자를 출력하는 print문 추가하라!
함수가 호출될때마다 표시되는 출력을 보면서 인자의값을 알수있다
인자가 베이트케이스 조건으로 이동하지않는다면 왜그런지 생각하라!



-실행흐름
print를 추가하자
함수이름을 쓰자
"entering function foo"


(3)프로그램 실행도중에 예외가 발생한다

Name Error
현재환경에 없는 변수를 사용하려고 하니까 발생!!
변수이름의 철자가 올바른가!
적어도 일관된 이름을 사용하는가!
지역변수는 범위안에서만 사용할수 있다!
로컬변수를 정의한 함수 밖에서 이를 참조하면 안된다!



Type Error
1. 값을 부적절하게 사용하려했다
=> 문자열/리스트/튜플 인덱스에 정수가 아닌 다른 것을 사용하니까 그러지!!

2. 서식 문자열의 항목과 변환을 위해 전달한 항목사이에 불일치가 발생함!
=>항목의 개수가 일치하지 않거나 부적절한 변환이 호출된 경우에 발생함!!

3. 함수에 전달하려는 인자의 개수가 잘못되었다.
메서드라면 메서드 정의를 살펴보고, 첫번째의 인자가 self인지 확인하고
메서드 호출을 확인한다. 
올바른 타입으로 메서드를 호출하는가?
다른인수는 올바르게 사용하는가? 확인해야지!

Key Error
사전에 포함되지 않은 키를 사용해 사전의 원소에 접근하는 경우에 발생함!
키가 문자열이라면 대소문자를 기억해야한다!

Attribute Error
존재하지않는 속성이나 메서드에 접근하는 경우 발생함!!
철자를 확인하자!
존재하는 속성목록을 얻기위해 내장함수 vars를 사용할수있다.
객체가 가리키는 AttributeError가 NoneType이라면 이는 없다는 뜻이다.
따라는 문제는 속성이름이 아니라 객체다.
객체가 없는 이유는 함수에서 값을 반환하는것을 잊었기 때문일수있다.
return문을 만나지않고 함수끝까지 도달한다면 함수는 None을 반환한다.
흔히 발생하는 다른원인으로는 sort같은 리스트메서드의 결과를 사용하지만 해당메서드가 None을 반환하는 경우이다.


Index Error
리스트/문자열/튜플에 사용하는 인덱스가 (길이-1) 보다 큰경우이다.
오류가 발생한 지점 바로앞에 인덱스값과 배열의 길이를 출력하는 print문을 추가하자
배열은 올바른 크기인가?
인덱스는 올바른 값인가?

파이썬 디버거(pdb)를 사용하면 오류가 발생한 바로앞에서 프로그램의 상태를 조사할수있으므로 예외를 추적할때 좋다.

Print문이 많아 출력내용이 너무많다
1. 출력을 단순화 하자!
=> 안쓰는거 주석처리 또는 제거
이해하기 쉽게 print문을 합치거나 출력형식을 다듬자!

2. 프로그램을 단순화하자!
프로그램이 동작하는 수준유지하면서 크기를 줄이자!
리스트 검색 => 작은 리스트로 교체

프로그램 정리하자!
프로그램의 가장깊은 중첩부분에서 문제가 의심된다면 해당부분을 더 간단한 구조로 재작성해보자
아주 큰 함수가 의심된다면 더 작은 함수로 나누고 작은함수를 테스트하자

테스트케이스를 아주 작게 만드는 과정이 종종 버그로 이끌어준다.
한쪽 상황에서는 프로그램이 동작하고 다른 상황에서는 프로그램이 동작하지않는다면
이것이 무슨일이 벌어지는지에 대한 단서를 제공할 것이다.


3. 의미 오류(Semantic Error)

1. 내 프로그램이 동작하지않는다

- 프로그램이 동작했어야하지만, 그렇게 되지않는 부분이 있는가?
함수를 수행하는 부분의 코드를 찾고 생각한대로 실행되는지 확인한다

- 그렇게되면 안되는부분이 있는가? 
프로그램에서 해당함수를 수행하는 부분을 찾고, 그렇게되면 안될때 실행되는지 확인한다.

- 일부코드가 예상한것돠 다른결과를 내놓는가? 코드를 이해하고 있는지 확인하자.
특히 다른 파이썬 모듈에 있는 함수나 메서드가 사용되었다면 더 의심해야한다.
호출한 함수에 대한 문서를 읽어보자.
간단한 테스트 케이스를 작성하고 결과를 확인하면서 함수를 테스트해보자.

프로그래밍을 하려면 프로그래밍이 어떻게 동작하는지에 대한 심상모형(mental model)이 필요하다.
예상대로 프로그램이 동작하지않으면 문제는 자신의 심상모형에 있다

심상모형을 올바르게 수정하는 가장좋은방법은 프로그램은 구성요소로,
보통은 함수나 메서드로 나누고, 각 구성요소를 개별적으로 테스트하는것이다.
심상모형과 실제가 불일치되는 부분을 발견했다면 문제를 해결할수있다.

물론 프로그램을 개발하면서 구성요소를 구축하고 테스트를 해야한다.
이렇게 하면 문제가 생겼을때 작은 크기의 새코드가 올바르지않다는것을 알수있다.

2. 크고 복잡한 표현식이 예상한대로 동작하지않는다

복잡한 표현식은 디버그하기 어려울수있다.
복잡한 표현식은 임시변수를 사용한 일련의 할당문으로 나누는것이 좋다.

self.hands[i].addCard(self.hands[self.findNeighbor(i)].popCard())
를 재작성하면

neighbor = self.findNeighbor(i)
pickedCard = self.hands[neighbor].popCard()
self.hands[i].addCard(pickedCard)

변수이름이 문서화의 역할을 하기때문에 명시적으로 작성한 코드가 더 쉽게 읽히며
중간변수의 타입을 확인하고 값을 표시할수있기때문에 디버그가 쉬워짐!!

큰표현식이 일으킬수있는 또다른 문제는 평가순서가 예상한것과 다를수있다는 것이다.
예를들어 수식 x/2파이를 파이썬으로 변환하면

y = x/2*math.pi

그러나 곱셈과 나눗셈은 같은 우선순위를 가지고 있으며 왼쪽에서 오른쪽으로 평가되므로
이코드는 올바르지않다
즉 이코드는 x파이/2를 계산하게 된다.

표현식의 버그를 잡는 좋은 방법은 괄호를 넣어 평가순서를 명확하게 정하는 것이다.
y=x/(2*math.pi)

평가순서를 확신할수없을때마다 괄호를 사용하자!


3. 의도한 것을 반환하지 않는 함수가 있다

임시변수를 사용하라!

return self.hands[i].removeMatches()
=>
count = self.hands[i].removeMatches()
return count

이렇게 바꾸면 return전에 count를 print해볼수있음!

4. 정말 꽉막혔음 도와주세요

-좌절과 분노
-미신과 징크스
-무작위행보 프로그래밍

5. 정말 도움이 필요함

-오류메세지가 있다면 무엇에 관한것이며, 프로그램의 어떤부분을 가리키고 있는가?
-이 오류가 발생하기 직전에 마지막으로 한일은 무엇인가?
-마지막으로 작성한 코드는 무엇이었는가?
-또는 실패한 새 테스트케이스는 무엇인가?
-지금까지 무엇을 시도했는가? 알게된것은 무엇인가?